% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{mobi2epub Documentation}
\date{January 25, 2013}
\release{0.01}
\author{JA}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{In-depth user guide}
\label{userguide:welcome-to-mobi2epub-s-documentation}\label{userguide:in-depth-user-guide}\label{userguide::doc}\begin{enumerate}
\item {} 
$_{\text{Disregard females}}$ acquire source code:

\begin{Verbatim}[commandchars=\\\{\}]
\$ git clone https://github.com/dipeptyd/mobi2epub.git
\end{Verbatim}

\item {} 
Compile it:

\begin{Verbatim}[commandchars=\\\{\}]
\$ cd mobi2epub \&\& make
\end{Verbatim}

\item {} 
get some .mobi book (not necessarily this one):

\begin{Verbatim}[commandchars=\\\{\}]
\$ fp="http://www.gutenberg.org/cache/epub/1232/pg1232.mobi"
\$ ua="Mozilla/4.0 (Windows; MSIE 7.0; Windows NT 5.1; SV1; .NET CLR 2.0.50727)"
\$ wget --user-agent=\$ua \$fp
\end{Verbatim}

\item {} 
\begin{Verbatim}[commandchars=\\\{\}]
\$ ./mobitoepub pg1232.mobi
saving to "/home/user/path/pg1232.epub"
\end{Verbatim}

\item {} 
read it on your favorite device.

\end{enumerate}


\chapter{mobi::}
\label{mobi:mobi}\label{mobi::doc}

\section{mobi::st\_c\_section}
\label{st_c_section:mobi-st-c-section}\label{st_c_section::doc}\index{mobi::st\_c\_section (C++ class)}

\begin{fulllineitems}
\phantomsection\label{st_c_section:mobi::st_c_section}\pysigline{\strong{class }\code{mobi::}\bfcode{st\_c\_section}}
Container used for simpler management of Content array by passing it's
size along with it

\end{fulllineitems}



\subsection{st\_c\_section variables}
\label{st_c_section:st-c-section-variables}

\subsubsection{public}
\label{st_c_section:public}\begin{quote}
\index{st\_c\_section::content (C++ member)}

\begin{fulllineitems}
\phantomsection\label{st_c_section:st_c_section::content__uint8P}\pysigline{uint8* \code{st\_c\_section::}\bfcode{content}}
Dynamic uint8\_t array

\end{fulllineitems}

\index{st\_c\_section::size (C++ member)}

\begin{fulllineitems}
\phantomsection\label{st_c_section:st_c_section::size__unsigned-i}\pysigline{unsigned int \code{st\_c\_section::}\bfcode{size}}
\end{fulllineitems}

\end{quote}


\subsection{st\_c\_section methods}
\label{st_c_section:st-c-section-methods}

\subsubsection{public}
\label{st_c_section:id1}\begin{quote}
\index{st\_c\_section (C++ function)}

\begin{fulllineitems}
\phantomsection\label{st_c_section:st_c_section}\pysiglinewithargsret{ \bfcode{st\_c\_section}}{}{}
Does nothing.

\end{fulllineitems}

\index{st\_c\_section (C++ function)}

\begin{fulllineitems}
\phantomsection\label{st_c_section:st_c_section__unsigned-i}\pysiglinewithargsret{ \bfcode{st\_c\_section}}{unsigned int \emph{x}}{}
Sets up {\hyperref[st_c_section:st_c_section::content__uint8P]{\code{st\_c\_section::content}}} to uint8{[}x{]}

and {\hyperref[st_c_section:st_c_section::size__unsigned-i]{\code{st\_c\_section::size}}} to x

\end{fulllineitems}

\index{\textasciitilde{}st\_c\_section (C++ function)}

\begin{fulllineitems}
\phantomsection\label{st_c_section:_st_c_section}\pysiglinewithargsret{ \bfcode{\textasciitilde{}st\_c\_section}}{}{}
Deletes \code{content}

\end{fulllineitems}

\end{quote}


\section{mobi::mobireader}
\label{mobireader:mobi-mobireader}\label{mobireader::doc}\index{mobi::mobireader (C++ class)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobi::mobireader}\pysigline{\strong{class }\code{mobi::}\bfcode{mobireader}}
Class for handling .mobi files

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{string}  \PYG{n}{foo} \PYG{o}{=} \PYG{l+s}{"}\PYG{l+s}{foo.mobi}\PYG{l+s}{"}\PYG{p}{;}

\PYG{n}{mobi}\PYG{o}{:}\PYG{o}{:}\PYG{n}{mobireader} \PYG{n}{bar}\PYG{p}{(}\PYG{n}{foo}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{std}\PYG{o}{:}\PYG{o}{:}\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{bar}\PYG{p}{.}\PYG{n}{get\PYGZus{}title}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}



\subsection{mobireader variables}
\label{mobireader:mobireader-variables}

\subsubsection{private}
\label{mobireader:private}\begin{quote}
\index{mobireader::db\_header (C++ member)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::db_header__st_palmdoc_db}\pysigline{{\hyperref[headers:st_palmdoc_db]{st\_palmdoc\_db}} \code{mobireader::}\bfcode{db\_header}}
\end{fulllineitems}

\index{mobireader::pd\_header (C++ member)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::pd_header__st_palmdoc}\pysigline{{\hyperref[headers:st_palmdoc]{st\_palmdoc}} \code{mobireader::}\bfcode{pd\_header}}
\end{fulllineitems}

\index{mobireader::mobi\_header (C++ member)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::mobi_header__st_mobi}\pysigline{{\hyperref[headers:st_mobi]{st\_mobi}} \code{mobireader::}\bfcode{mobi\_header}}
\end{fulllineitems}

\index{mobireader::section\_offsets (C++ member)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::section_offsets__vector:uint32_t:}\pysigline{vector\textless{}uint32\_t\textgreater{} \code{mobireader::}\bfcode{section\_offsets}}
byte offset of every data section in the file

\end{fulllineitems}

\index{mobireader::c\_section (C++ member)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::c_section__st_c_section}\pysigline{st\_c\_section \code{mobireader::}\bfcode{c\_section}}
instance of {\hyperref[st_c_section:mobi::st_c_section]{\code{mobi::st\_c\_section}}}

\end{fulllineitems}

\index{mobireader::input\_file\_name (C++ member)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::input_file_name__string}\pysigline{string \code{mobireader::}\bfcode{input\_file\_name}}
name of the file, because ifstream is too cool to keep that by itself.

\begin{notice}{note}{Note:}
Actually, it's the whole path used in the constructor
\end{notice}

\end{fulllineitems}

\index{mobireader::file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::file__ifstreamP}\pysigline{ifstream* \code{mobireader::}\bfcode{file}}
All it should do is to get passed to the {\hyperref[mobireader:mobireader::handler__header_handlerP]{\code{handler}}}

\end{fulllineitems}

\index{mobireader::reader (C++ member)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::reader__compressionP}\pysigline{compression* \code{mobireader::}\bfcode{reader}}
Pointer to a dynamic instance of {\hyperref[compression:mobi::compression]{\code{mobi::compression}}}

\end{fulllineitems}

\index{mobireader::handler (C++ member)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::handler__header_handlerP}\pysigline{header\_handler* \code{mobireader::}\bfcode{handler}}
pointer to a dynamic instance of {\hyperref[header_handler:header_handler]{\code{header\_handler}}}

\end{fulllineitems}

\index{mobireader::title (C++ member)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::title__cP}\pysigline{char* \code{mobireader::}\bfcode{title}}
title of the book,
set by
{\hyperref[mobireader:mobireader::set_title__cCP]{\code{set\_title()}}} and {\hyperref[mobireader:set_default_title]{\code{set\_default\_title()}}} methods

\end{fulllineitems}

\end{quote}


\subsection{mobireader methods}
\label{mobireader:mobireader-methods}

\subsubsection{private}
\label{mobireader:id1}\begin{quote}
\index{parse\_header (C++ function)}

\begin{fulllineitems}
\phantomsection\label{mobireader:parse_header}\pysiglinewithargsret{mobireader::void \bfcode{parse\_header}}{}{}
loads up headers structures and fills the {\hyperref[mobireader:mobireader::section_offsets__vector:uint32_t:]{\code{mobireader::section\_offsets}}} vector

if {\hyperref[mobireader:mobireader::db_header__st_palmdoc_db]{\code{mobireader::db\_header}}} type doesn't equal BOOKMOBI, throws
{\hyperref[exceptions:mobi::invalid_file_exception]{\code{mobi::invalid\_file\_exception}}}

\end{fulllineitems}

\index{set\_compression (C++ function)}

\begin{fulllineitems}
\phantomsection\label{mobireader:set_compression}\pysiglinewithargsret{mobireader::void \bfcode{set\_compression}}{}{}
decides which one of the mobi::compression classes should {\hyperref[mobireader:mobireader::reader__compressionP]{\code{mobireader::reader}}} point to

throws unsupported\_compressiontype\_exception for dictionary compression.
mainly because i haven't found it in any of my books.

\end{fulllineitems}

\index{mobireader::get\_section\_uncompressed (C++ function)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::get_section_uncompressed__unsigned-iC}\pysiglinewithargsret{std::string \code{mobireader::}\bfcode{get\_section\_uncompressed}}{unsigned int \emph{s}}{\code{~const}}
Handles uncompression and returns the uncompressed text.

throws {\hyperref[exceptions:mobi::section_out_of_range_exception]{\code{mobi::section\_out\_of\_range\_exception}}}
when... the section is out of range

\end{fulllineitems}

\index{mobireader::load\_file (C++ function)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::load_file__ssR}\pysiglinewithargsret{void \code{mobireader::}\bfcode{load\_file}}{std::string\& \emph{input\_file\_name}}{}
loads file from path in input\_file\_name string and sets up {\hyperref[mobireader:mobireader::handler__header_handlerP]{\code{handler}}} and {\hyperref[mobireader:mobireader::file__ifstreamP]{\code{file}}} pointers.

\end{fulllineitems}

\end{quote}


\subsubsection{public:}
\label{mobireader:public}\begin{quote}
\index{mobireader::mobireader (C++ function)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::mobireader__ssR}\pysiglinewithargsret{ \code{mobireader::}\bfcode{mobireader}}{std::string\& \emph{input\_file\_name}}{}
Does all the magic necessary, calls {\hyperref[mobireader:mobireader::load_file__ssR]{\code{mobireader::load\_file()}}} for input\_file\_name

\end{fulllineitems}

\index{mobireader::mobireader (C++ function)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::mobireader__mobireaderCR}\pysiglinewithargsret{ \code{mobireader::}\bfcode{mobireader}}{const mobireader\& \emph{m}}{}
Copy constructor. Uses {\hyperref[mobireader:mobireader::assign-operator__mobireaderCR]{\code{mobireader::operator=()}}}

\end{fulllineitems}

\index{mobireader::mobireader (C++ function)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::mobireader}\pysiglinewithargsret{ \code{mobireader::}\bfcode{mobireader}}{}{}
A Constructor that actually does nothing.

\end{fulllineitems}

\index{mobireader::\textasciitilde{}mobireader (C++ function)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::_mobireader}\pysiglinewithargsret{ \code{mobireader::}\bfcode{\textasciitilde{}mobireader}}{}{}
Frees {\hyperref[mobireader:mobireader::reader__compressionP]{\code{reader}}}, {\hyperref[mobireader:mobireader::file__ifstreamP]{\code{file}}}, {\hyperref[mobireader:mobireader::title__cP]{\code{title}}} and {\hyperref[mobireader:mobireader::handler__header_handlerP]{\code{handler}}}

\end{fulllineitems}

\index{set\_default\_title (C++ function)}

\begin{fulllineitems}
\phantomsection\label{mobireader:set_default_title}\pysiglinewithargsret{mobireader::void \bfcode{set\_default\_title}}{}{}
reads the default title from file and calls {\hyperref[mobireader:mobireader::set_title__cCP]{\code{mobireader::set\_title()}}} with it as an argument.

\end{fulllineitems}

\index{mobireader::set\_title (C++ function)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::set_title__cCP}\pysiglinewithargsret{char* \code{mobireader::}\bfcode{set\_title}}{const char* \emph{s}}{}
Sets the char* s copy as the book title.

Also handles deleting the old one.

\end{fulllineitems}

\index{mobireader::get\_title (C++ function)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::get_titleC}\pysiglinewithargsret{char* \code{mobireader::}\bfcode{get\_title}}{}{\code{~const}}
returns current book {\hyperref[mobireader:mobireader::title__cP]{\code{title}}}.

\end{fulllineitems}

\index{mobireader::get\_html (C++ function)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::get_htmlC}\pysiglinewithargsret{std::string \code{mobireader::}\bfcode{get\_html}}{}{\code{~const}}
iterates {\hyperref[mobireader:mobireader::reader__compressionP]{\code{mobireader::reader}}} over sections and returns html-like text.

\end{fulllineitems}

\index{mobireader::get\_file\_name (C++ function)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::get_file_nameC}\pysiglinewithargsret{std::string \code{mobireader::}\bfcode{get\_file\_name}}{}{\code{~const}}
returns file name from {\hyperref[mobireader:mobireader::input_file_name__string]{\code{mobireader::input\_file\_name}}}

\begin{notice}{note}{Note:}
Actually this tends to be the full path used
\end{notice}

\end{fulllineitems}

\index{mobireader::operator= (C++ function)}

\begin{fulllineitems}
\phantomsection\label{mobireader:mobireader::assign-operator__mobireaderCR}\pysiglinewithargsret{void \code{mobireader::}\bfcode{operator=}}{const mobireader\& \emph{m}}{}
obviously copies mobireader instance onto current one.
calls {\hyperref[mobireader:mobireader::load_file__ssR]{\code{load\_file()}}}

\end{fulllineitems}

\end{quote}


\section{mobi headers}
\label{headers:mobi-headers}\label{headers::doc}\index{st\_palmdoc\_db (C++ type)}

\begin{fulllineitems}
\phantomsection\label{headers:st_palmdoc_db}\pysigline{\strong{type }\bfcode{st\_palmdoc\_db}}
Should be equal to 78 bytes.

\begin{Verbatim}[commandchars=\\\{\}]
char   name[32];
uint16\_t flags;
uint16\_t version;
uint32\_t c\_time;
uint32\_t m\_time;
uint32\_t b\_time;
uint32\_t mod\_num;
uint32\_t app\_info;
uint32\_t sort\_info;
char   type[8]; //BOOKMOBI
uint32\_t u\_id\_seed;
uint32\_t next\_record\_list;
uint16\_t num\_records;
\end{Verbatim}

\end{fulllineitems}

\index{st\_palmdoc (C++ type)}

\begin{fulllineitems}
\phantomsection\label{headers:st_palmdoc}\pysigline{\strong{type }\bfcode{st\_palmdoc}}
Should be equal to 16 bytes.

\begin{Verbatim}[commandchars=\\\{\}]
uint16\_t compression
uint16\_t garbage
uint32\_t text\_length
uint16\_t record\_count
uint16\_t record\_size
uint32\_t current\_pos
\end{Verbatim}

\end{fulllineitems}

\index{st\_mobi (C++ type)}

\begin{fulllineitems}
\phantomsection\label{headers:st_mobi}\pysigline{\strong{type }\bfcode{st\_mobi}}
Should be equal to 232 bytes.

\begin{Verbatim}[commandchars=\\\{\}]
char   id[4]
uint32\_t header\_len
uint32\_t mobi\_type
uint32\_t text\_encoding
uint32\_t u\_id
uint32\_t file\_version
uint32\_t ortographic\_index
uint32\_t inflection\_index
uint32\_t index\_names
uint32\_t index\_keys
uint32\_t extra\_index0
uint32\_t extra\_index1
uint32\_t extra\_index2
uint32\_t extra\_index3
uint32\_t extra\_index4
uint32\_t extra\_index5
uint32\_t first\_nonbook\_index
uint32\_t full\_name\_offset
uint32\_t full\_name\_length
uint32\_t locale
uint32\_t input\_language
uint32\_t output\_language
uint32\_t min\_version
uint32\_t first\_image\_index
uint32\_t huffman\_record\_offset
uint32\_t huffman\_record\_count
uint32\_t huffman\_table\_offset
uint32\_t huffman\_table\_length
uint32\_t exth\_flags
char   garbage[32]
uint32\_t drm\_offset
uint32\_t drm\_count
uint32\_t drm\_size
uint32\_t drm\_flags
char   garbage2[12]
uint16\_t first\_content\_record\_number
uint16\_t last\_content\_record\_number
uint32\_t unknown
uint32\_t fcis\_record\_number
uint32\_t fcis\_record\_count
uint32\_t flis\_record\_number
uint32\_t flis\_record\_count
uint64\_t unk0
uint32\_t unk1
uint32\_t unk2
uint32\_t unk3
uint32\_t unk4
uint32\_t extra\_record\_data\_flags
uint32\_t indx\_record\_offset
\end{Verbatim}

\end{fulllineitems}



\section{mobi::header\_handler}
\label{header_handler:mobi-header-handler}\label{header_handler::doc}\index{header\_handler (C++ class)}

\begin{fulllineitems}
\phantomsection\label{header_handler:header_handler}\pysigline{\strong{class }\bfcode{header\_handler}}
Handles reading data from the .mobi files, so the {\hyperref[mobireader:mobi::mobireader]{\code{mobi::mobireader}}}
methods can be a bit cleaner.

\end{fulllineitems}



\subsection{header\_handler variables}
\label{header_handler:header-handler-variables}

\subsubsection{private}
\label{header_handler:private}

\subsection{header\_handler methods}
\label{header_handler:header-handler-methods}\begin{quote}
\index{header\_handler::file (C++ member)}

\begin{fulllineitems}
\phantomsection\label{header_handler:header_handler::file__std::ifstreamP}\pysigline{std::ifstream* \code{header\_handler::}\bfcode{file}}
\end{fulllineitems}

\end{quote}


\subsubsection{public:}
\label{header_handler:public}\index{header\_handler (C++ function)}

\begin{fulllineitems}
\phantomsection\label{header_handler:header_handler__std::ifstreamP}\pysiglinewithargsret{ \bfcode{header\_handler}}{std::ifstream* \emph{file}}{}
Sets up {\hyperref[header_handler:header_handler::file__std::ifstreamP]{\code{file}}} pointer to
{\hyperref[mobireader:mobireader::file__ifstreamP]{\code{mobireader::file}}}

\end{fulllineitems}

\index{header\_handler::offset (C++ function)}

\begin{fulllineitems}
\phantomsection\label{header_handler:header_handler::offset__unsigned-i}\pysiglinewithargsret{header\_handler\& \code{header\_handler::}\bfcode{offset}}{unsigned int \emph{offset}}{}
Sets offset in {\hyperref[header_handler:header_handler::file__std::ifstreamP]{\code{file}}}

returns reference to self

\end{fulllineitems}

\index{header\_handler::skip (C++ function)}

\begin{fulllineitems}
\phantomsection\label{header_handler:header_handler::skip__unsigned-i}\pysiglinewithargsret{header\_handler\& \code{header\_handler::}\bfcode{skip}}{unsigned int \emph{skip}}{}
Skips n bytes in {\hyperref[header_handler:header_handler::file__std::ifstreamP]{\code{file}}}

returns reference to self

\end{fulllineitems}

\index{header\_handler::read (C++ function)}

\begin{fulllineitems}
\phantomsection\label{header_handler:header_handler::read__typeR}\pysiglinewithargsret{header\_handler\& \code{header\_handler::}\bfcode{read}}{type\& \emph{i}}{}
Reads sizeof i from {\hyperref[header_handler:header_handler::file__std::ifstreamP]{\code{file}}} and saves it to i

returns reference to {\hyperref[header_handler:header_handler]{\code{header\_handler}}}

\end{fulllineitems}

\index{header\_handler::read (C++ function)}

\begin{fulllineitems}
\phantomsection\label{header_handler:header_handler::read__typeR.unsigned-i}\pysiglinewithargsret{header\_handler\& \code{header\_handler::}\bfcode{read}}{type\& \emph{i}, unsigned int \emph{n}}{}
Reads n times sizeof i from {\hyperref[header_handler:header_handler::file__std::ifstreamP]{\code{file}}} and saves it to i

Should be overloaded for every necessary data type combination

$_{\text{Or just use templates, but the linker seems to stupid to handle the current
source code layout}}$

returns reference to self

\end{fulllineitems}



\section{mobi::compression}
\label{compression:mobi-compression}\label{compression::doc}\index{mobi::compression (C++ class)}

\begin{fulllineitems}
\phantomsection\label{compression:mobi::compression}\pysigline{\strong{class }\code{mobi::}\bfcode{compression}}
abstract class, provides base for {\hyperref[compression:mobi::pd_compression]{\code{pd\_compression}}}, {\hyperref[compression:mobi::no_compression]{\code{no\_compression}}}
and {\hyperref[compression:mobi::hd_compression]{\code{hd\_compression}}}

\end{fulllineitems}



\subsection{compression variables}
\label{compression:compression-variables}

\subsubsection{private}
\label{compression:private}\begin{quote}
\index{destination (C++ member)}

\begin{fulllineitems}
\phantomsection\label{compression:destination__ss}\pysigline{std::string \bfcode{destination}}
\end{fulllineitems}

\end{quote}


\subsection{compression methods}
\label{compression:compression-methods}

\subsubsection{public:}
\label{compression:public}\index{compression::uncompress (C++ function)}

\begin{fulllineitems}
\phantomsection\label{compression:compression::uncompress__uint8_tP.s}\pysiglinewithargsret{void \code{compression::}\bfcode{uncompress}}{uint8\_t* \emph{src}, size\_t \emph{srcLen}}{\code{~=~0}}~
\begin{notice}{note}{Note:}
pure virtual function
\end{notice}

Should be overloaded with:

\begin{Verbatim}[commandchars=\\\{\}]
if(!this-\textgreater{}destination.empty())
    this-\textgreater{}destination.clear();
(decompression algorithm that appends stuff to this-\textgreater{}destination)
return;
\end{Verbatim}

\end{fulllineitems}

\index{compression::output\_raw (C++ function)}

\begin{fulllineitems}
\phantomsection\label{compression:compression::output_raw}\pysiglinewithargsret{std::string \code{compression::}\bfcode{output\_raw}}{}{}~
\begin{notice}{note}{Note:}
virtual function
\end{notice}

Usually should just:

\begin{Verbatim}[commandchars=\\\{\}]
return this-\textgreater{}destination;
\end{Verbatim}

\end{fulllineitems}

\index{mobi::pd\_compression (C++ class)}

\begin{fulllineitems}
\phantomsection\label{compression:mobi::pd_compression}\pysigline{\strong{class }\code{mobi::}\bfcode{pd\_compression}}
inherits from {\hyperref[compression:mobi::compression]{\code{compression}}}

Uses PalmDoc algorithm:
\begin{enumerate}
\item {} 
Read a byte from the compressed stream. If the byte is

\item {} 
0x00: ``1 literal'' copy that byte unmodified to the decompressed stream.

\item {} 
0x09 to 0x7f: ``1 literal'' copy that byte unmodified to the decompressed stream.

\item {} 
0x01 to 0x08: ``literals'': the byte is interpreted as a count from 1 to 8, and that many literals are copied unmodified from the compressed stream to the decompressed stream.

\item {} 
0x80 to 0xbf: ``length, distance'' pair: the 2 leftmost bits of this byte (`10') are discarded, and the following 6 bits are combined with the 8 bits of the next byte to make a 14 bit ``distance, length'' item. Those 14 bits are broken into 11 bits of distance backwards from the current location in the uncompressed text, and 3 bits of length to copy from that point (copying n+3 bytes, 3 to 10 bytes).

\item {} 
0xc0 to 0xff: ``byte pair'': this byte is decoded into 2 characters: a space character, and a letter formed from this byte XORed with 0x80.

\item {} 
Repeat from the beginning until there is no more bytes in the compressed f

\end{enumerate}

Except it doesn't copy 0x00. Because who in the right mind would want to do that?

throws {\hyperref[exceptions:mobi::not_palmdoc_compression_exception]{\code{mobi::not\_palmdoc\_compression\_exception}}}
from check at stage 5.

\end{fulllineitems}

\index{mobi::no\_compression (C++ class)}

\begin{fulllineitems}
\phantomsection\label{compression:mobi::no_compression}\pysigline{\strong{class }\code{mobi::}\bfcode{no\_compression}}
inherits from {\hyperref[compression:mobi::compression]{\code{compression}}}

It's just:

\begin{Verbatim}[commandchars=\\\{\}]
if(!this-\textgreater{}destination.empty())
    this-\textgreater{}destination.clear();
this-\textgreater{}destination.append((char *)src, srcLen);
\end{Verbatim}

in {\hyperref[compression:compression::uncompress__uint8_tP.s]{\code{compression::uncompress()}}}

\end{fulllineitems}

\index{mobi::hd\_compression (C++ class)}

\begin{fulllineitems}
\phantomsection\label{compression:mobi::hd_compression}\pysigline{\strong{class }\code{mobi::}\bfcode{hd\_compression}}
inherits from {\hyperref[compression:mobi::compression]{\code{compression}}}

currently not implemented, because none of the books i've found use it.

\end{fulllineitems}



\section{separate mobi::functions}
\label{functions:separate-mobi-functions}\label{functions::doc}\index{mobi::strcmp\_is\_a\_worthless\_pos (C++ function)}

\begin{fulllineitems}
\phantomsection\label{functions:mobi::strcmp_is_a_worthless_pos__cP.cP.iP}\pysiglinewithargsret{ \code{mobi::}\bfcode{strcmp\_is\_a\_worthless\_pos}}{char* \emph{x}, char* \emph{y}, int* \emph{n}}{}
compares x and y arrays up to n.
returns true if they match

\end{fulllineitems}

\index{bswap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{functions:bswap__uint16_tR}\pysiglinewithargsret{void \bfcode{bswap}}{uint16\_t\& \emph{x}}{}
\end{fulllineitems}

\index{bswap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{functions:bswap__uint32_tR}\pysiglinewithargsret{void \bfcode{bswap}}{uint32\_t\& \emph{x}}{}
\end{fulllineitems}

\index{bswap (C++ function)}

\begin{fulllineitems}
\phantomsection\label{functions:bswap__uint64_tR}\pysiglinewithargsret{void \bfcode{bswap}}{uint64\_t\& \emph{x}}{}
switch variable endianess on little endian architecture.

\end{fulllineitems}

\index{unretardify\_header (C++ function)}

\begin{fulllineitems}
\phantomsection\label{functions:unretardify_header__st_palmdoc_dbR}\pysiglinewithargsret{void \bfcode{unretardify\_header}}{{\hyperref[headers:st_palmdoc_db]{st\_palmdoc\_db\&}} \emph{x}}{}
\end{fulllineitems}

\index{unretardify\_header (C++ function)}

\begin{fulllineitems}
\phantomsection\label{functions:unretardify_header__st_palmdocR}\pysiglinewithargsret{void \bfcode{unretardify\_header}}{{\hyperref[headers:st_palmdoc]{st\_palmdoc\&}} \emph{x}}{}
\end{fulllineitems}

\index{unretardify\_header (C++ function)}

\begin{fulllineitems}
\phantomsection\label{functions:unretardify_header__st_mobiR}\pysiglinewithargsret{void \bfcode{unretardify\_header}}{{\hyperref[headers:st_mobi]{st\_mobi\&}} \emph{x}}{}
bswap every value in those structures.

\end{fulllineitems}



\chapter{epub::}
\label{epub:epub}\label{epub::doc}

\section{epub::html::}
\label{tidyhtml:epub-html}\label{tidyhtml::doc}

\subsection{epub::html::tidyhtml}
\label{tidyhtml:epub-html-tidyhtml}\index{epub::html::tidyhtml (C++ class)}

\begin{fulllineitems}
\phantomsection\label{tidyhtml:epub::html::tidyhtml}\pysigline{\strong{class }\code{epub::html::}\bfcode{tidyhtml}}
turns ugly mobi html into even uglier xhtml

\end{fulllineitems}



\subsubsection{variables}
\label{tidyhtml:variables}

\paragraph{private}
\label{tidyhtml:private}\index{epub::html::tidyhtml::tdoc (C++ member)}

\begin{fulllineitems}
\phantomsection\label{tidyhtml:epub::html::tidyhtml::tdoc__TidyDoc}\pysigline{TidyDoc \code{epub::html::tidyhtml::}\bfcode{tdoc}}
\href{http://tidy.sourceforge.net/\#docs}{http://tidy.sourceforge.net/\#docs}

\end{fulllineitems}



\subsubsection{methods}
\label{tidyhtml:methods}

\paragraph{public}
\label{tidyhtml:public}\index{epub::html::tidyhtml::tidyhtml (C++ function)}

\begin{fulllineitems}
\phantomsection\label{tidyhtml:epub::html::tidyhtml::tidyhtml}\pysiglinewithargsret{ \code{epub::html::tidyhtml::}\bfcode{tidyhtml}}{}{}
sets up {\hyperref[tidyhtml:epub::html::tidyhtml::tdoc__TidyDoc]{\code{tdoc}}} and related options:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{tidyOptSetBool}\PYG{p}{(} \PYG{n}{tdoc}\PYG{p}{,} \PYG{n}{TidyXhtmlOut}\PYG{p}{,} \PYG{n}{yes}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{tidyOptSetBool}\PYG{p}{(} \PYG{n}{tdoc}\PYG{p}{,} \PYG{n}{TidyForceOutput}\PYG{p}{,} \PYG{n}{yes}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{tidyOptSetBool}\PYG{p}{(} \PYG{n}{tdoc}\PYG{p}{,} \PYG{n}{TidyShowWarnings}\PYG{p}{,} \PYG{n}{no}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{tidyOptSetBool}\PYG{p}{(} \PYG{n}{tdoc}\PYG{p}{,} \PYG{n}{TidyQuiet}\PYG{p}{,} \PYG{n}{yes}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{tidyOptSetInt}\PYG{p}{(} \PYG{n}{tdoc}\PYG{p}{,} \PYG{n}{TidyShowErrors}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{tidySetCharEncoding}\PYG{p}{(}\PYG{n}{tdoc}\PYG{p}{,} \PYG{l+s}{"}\PYG{l+s}{utf8}\PYG{l+s}{"}\PYG{p}{)}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{parse (C++ function)}

\begin{fulllineitems}
\phantomsection\label{tidyhtml:parse__ss.ss}\pysiglinewithargsret{void \bfcode{parse}}{std::string \emph{html\_code}, std::string \emph{path}}{}
it doesn't only parse, but also writes to a file!

\end{fulllineitems}


Namespace for classes that read .epub, write .epub and convert to .epub
\index{container\_xml (C++ member)}

\begin{fulllineitems}
\phantomsection\label{epub:container_xml__ss}\pysigline{std::string \bfcode{container\_xml}}
\href{http://wiki.mobileread.com/wiki/EPUB\#container.xml}{http://wiki.mobileread.com/wiki/EPUB\#container.xml}

\begin{Verbatim}[commandchars=\\\{\}]
\textless{}?xml version=\PYGZbs{}"1.0\PYGZbs{}"?\textgreater{}\PYGZbs{}n\PYGZbs{}
\textless{}container version=\PYGZbs{}"1.0\PYGZbs{}" xmlns=\PYGZbs{}"urn:oasis:names:tc:opendocument:xmlns:container\PYGZbs{}"\textgreater{}\PYGZbs{}n\PYGZbs{}
\textless{}rootfiles\textgreater{}\PYGZbs{}n\PYGZbs{}
    \textless{}rootfile full-path=\PYGZbs{}"OEBPS/content.opf\PYGZbs{}" media-type=\PYGZbs{}"application/oebps-package+xml\PYGZbs{}"/\textgreater{}\PYGZbs{}n\PYGZbs{}
    \PYGZbs{}n\PYGZbs{}
\textless{}/rootfiles\textgreater{}\PYGZbs{}n\PYGZbs{}
\textless{}/container\textgreater{}"
\end{Verbatim}

\end{fulllineitems}

\index{mimetype (C++ member)}

\begin{fulllineitems}
\phantomsection\label{epub:mimetype__ss}\pysigline{std::string \bfcode{mimetype}}
\href{http://wiki.mobileread.com/wiki/EPUB\#mimetype}{http://wiki.mobileread.com/wiki/EPUB\#mimetype}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{l+s}{"}\PYG{l+s}{application/epub+zip}\PYG{l+s}{"}\PYG{p}{;}
\end{Verbatim}

\end{fulllineitems}

\index{content\_opf (C++ member)}

\begin{fulllineitems}
\phantomsection\label{epub:content_opf__ss}\pysigline{std::string \bfcode{content\_opf}}
\href{http://wiki.mobileread.com/wiki/EPUB\#OPF}{http://wiki.mobileread.com/wiki/EPUB\#OPF}

\begin{Verbatim}[commandchars=\\\{\}]
\textless{}?xml version=\PYGZbs{}"1.0\PYGZbs{}" encoding=\PYGZbs{}"utf-8\PYGZbs{}" standalone=\PYGZbs{}"yes\PYGZbs{}"?\textgreater{}\PYGZbs{}n\PYGZbs{}
\textless{}package xmlns=\PYGZbs{}"http://www.idpf.org/2007/opf\PYGZbs{}" unique-identifier=\PYGZbs{}"BookId\PYGZbs{}" version=\PYGZbs{}"2.0\PYGZbs{}"\textgreater{}\PYGZbs{}n\PYGZbs{}
    \textless{}metadata xmlns:dc=\PYGZbs{}"http://purl.org/dc/elements/1.1/\PYGZbs{}" xmlns:opf=\PYGZbs{}"http://www.idpf.org/2007/opf\PYGZbs{}"\textgreater{}\PYGZbs{}n\PYGZbs{}
        \textless{}dc:title\textgreater{}\%1\%\textless{}/dc:title\textgreater{} \PYGZbs{}n\PYGZbs{}
    \textless{}/metadata\textgreater{}\PYGZbs{}n\PYGZbs{}
    \textless{}manifest\textgreater{}\PYGZbs{}n\PYGZbs{}n\PYGZbs{}
\PYGZbs{}
\%2\%\PYGZbs{}n\PYGZbs{}   //itemid
\PYGZbs{}
    \textless{}/manifest\textgreater{}\PYGZbs{}n\PYGZbs{}
    \textless{}spine toc=\PYGZbs{}"ncx\PYGZbs{}"\textgreater{}\PYGZbs{}n\PYGZbs{}n\PYGZbs{}
\PYGZbs{}
\%3\%\PYGZbs{}n\PYGZbs{} //itemref
\PYGZbs{}
    \textless{}/spine\textgreater{}\PYGZbs{}n\PYGZbs{}
\textless{}/package\textgreater{}\PYGZbs{}n\PYGZbs{}
\end{Verbatim}

title string comes from {\hyperref[mobireader:mobireader::get_titleC]{\code{mobireader::get\_title()}}}

\end{fulllineitems}

\index{itemid (C++ member)}

\begin{fulllineitems}
\phantomsection\label{epub:itemid__ss}\pysigline{std::string \bfcode{itemid}}
format string for {\hyperref[epub:content_opf__ss]{\code{content\_opf}}}

\end{fulllineitems}

\index{itemref (C++ member)}

\begin{fulllineitems}
\phantomsection\label{epub:itemref__ss}\pysigline{std::string \bfcode{itemref}}
format string for {\hyperref[epub:content_opf__ss]{\code{content\_opf}}}

\end{fulllineitems}



\section{epub::mobi2epub}
\label{epub:epub-mobi2epub}\index{epub::mobi2epub (C++ class)}

\begin{fulllineitems}
\phantomsection\label{epub:epub::mobi2epub}\pysigline{\strong{class }\code{epub::}\bfcode{mobi2epub}}
Class converting .mobi files to .epub

and because of lame
.zip support  writes them on the disk immediately.

$_{\text{actually it's still in ram, thanks to tmpfs, nonetheless, could be better}}$

\end{fulllineitems}



\subsection{mobi2epub variables}
\label{epub:mobi2epub-variables}

\subsubsection{private}
\label{epub:private}\index{path\_out (C++ member)}

\begin{fulllineitems}
\phantomsection\label{epub:path_out__boost::filesystem::path}\pysigline{boost::filesystem::path \bfcode{path\_out}}
Path to the output file \emph{obviously including file name}

Used in {\hyperref[epub:mobi2epub::directory_to_epubC]{\code{mobi2epub::directory\_to\_epub()}}}

Set in {\hyperref[epub:mobi2epub::mobi2epub__mobi2epubR]{\code{mobi2epub::mobi2epub()}}}

\end{fulllineitems}

\index{path\_tmp (C++ member)}

\begin{fulllineitems}
\phantomsection\label{epub:path_tmp__boost::filesystem::path}\pysigline{boost::filesystem::path \bfcode{path\_tmp}}
Path to the temporary directory, used to save the entire uncompressed file structure

Set in {\hyperref[epub:mobi2epub::mobi2epub__mobi2epubR]{\code{mobi2epub::mobi2epub()}}}

\begin{notice}{note}{Note:}
Currently supports path only for unix
\end{notice}

\end{fulllineitems}

\index{m (C++ member)}

\begin{fulllineitems}
\phantomsection\label{epub:m__mobi::mobireader}\pysigline{mobi::mobireader \bfcode{m}}
instance of {\hyperref[mobireader:mobi::mobireader]{\code{mobi::mobireader}}} copied in {\hyperref[epub:mobi2epub::mobi2epub__mobi2epubR]{\code{mobi2epub::mobi2epub()}}}

\end{fulllineitems}

\index{safe (C++ member)}

\begin{fulllineitems}
\phantomsection\label{epub:safe__mutable-b}\pysigline{mutable bool \bfcode{safe}}
Tells if it's ok to wipe the user's drive \textasciicircum{}W\textasciicircum{}W\textasciicircum{}W\textasciicircum{}W run {\hyperref[epub:mobi2epub::directory_structureC]{\code{mobi2epub::directory\_structure()}}}

\end{fulllineitems}

\index{no\_cleanup (C++ member)}

\begin{fulllineitems}
\phantomsection\label{epub:no_cleanup__mutable-b}\pysigline{mutable bool \bfcode{no\_cleanup}}
Makes {\hyperref[epub:mobi2epub::cleanupC]{\code{mobi2epub::cleanup()}}} exit immediately

\end{fulllineitems}

\index{vanilla\_out (C++ member)}

\begin{fulllineitems}
\phantomsection\label{epub:vanilla_out__mutable-b}\pysigline{mutable bool \bfcode{vanilla\_out}}
Checks if {\hyperref[epub:mobi2epub::set_out__ssR]{\code{mobi2epub::set\_out()}}} was called and {\hyperref[epub:path_out__boost::filesystem::path]{\code{path\_out}}}
isn't default anymore.

\end{fulllineitems}



\subsection{mobi2epub methods}
\label{epub:mobi2epub-methods}

\subsubsection{private}
\label{epub:id1}\index{mobi2epub::directory\_structure (C++ function)}

\begin{fulllineitems}
\phantomsection\label{epub:mobi2epub::directory_structureC}\pysiglinewithargsret{void \code{mobi2epub::}\bfcode{directory\_structure}}{}{\code{~const}}
Creates the static part of every .epub file:

\begin{Verbatim}[commandchars=\\\{\}]
path\_tmp/
         OEBPS/
         OEBPS/text/
         OEBPS/META-INF/
         META-INF/container.xml
         mimetype
\end{Verbatim}

checks if already exists, if so ask to whether {\hyperref[epub:mobi2epub::cleanupC]{\code{remove}}}
or set to {\hyperref[epub:safe__mutable-b]{\code{safe}}} and continue

\end{fulllineitems}

\index{mobi2epub::cleanup (C++ function)}

\begin{fulllineitems}
\phantomsection\label{epub:mobi2epub::cleanupC}\pysiglinewithargsret{void \code{mobi2epub::}\bfcode{cleanup}}{}{\code{~const}}~
\begin{notice}{warning}{Warning:}
Removes recursively every file in {\hyperref[epub:path_tmp__boost::filesystem::path]{\code{path\_tmp}}} without asking if {\hyperref[epub:safe__mutable-b]{\code{safe}}} is set to \textbf{True}

should be handled with caution.
\end{notice}

{\hyperref[epub:no_cleanup__mutable-b]{\code{no\_cleanup}}} decides whether it should return instantly

Throws {\hyperref[exceptions:epub::user_wants_out_exception]{\code{epub::user\_wants\_out\_exception}}} if the user decides to quit

\end{fulllineitems}

\index{mobi2epub::gen\_content\_opf (C++ function)}

\begin{fulllineitems}
\phantomsection\label{epub:mobi2epub::gen_content_opf__std::stringstreamR.std::stringstreamRC}\pysiglinewithargsret{void \code{mobi2epub::}\bfcode{gen\_content\_opf}}{std::stringstream\& \emph{itemids}, std::stringstream\& \emph{itemrefs}}{\code{~const}}
Generates {\hyperref[epub:content_opf__ss]{\code{content\_opf}}} and saves it to:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{OEBPS}\PYG{o}{/}\PYG{n}{content}\PYG{o}{.}\PYG{n}{opf}
\end{Verbatim}

\end{fulllineitems}

\index{mobi2epub::operator= (C++ function)}

\begin{fulllineitems}
\phantomsection\label{epub:mobi2epub::assign-operator__mobi2epubR}\pysiglinewithargsret{void \code{mobi2epub::}\bfcode{operator=}}{mobi2epub\& \emph{m}}{}
Makes the class uncopyable

\end{fulllineitems}

\index{mobi2epub::mobi2epub (C++ function)}

\begin{fulllineitems}
\phantomsection\label{epub:mobi2epub::mobi2epub__mobi2epubR}\pysiglinewithargsret{ \code{mobi2epub::}\bfcode{mobi2epub}}{mobi2epub\& \emph{m}}{}
Makes the class uncopyable even more

\end{fulllineitems}

\index{mobi2epub::set\_out (C++ function)}

\begin{fulllineitems}
\phantomsection\label{epub:mobi2epub::set_out__ssR}\pysiglinewithargsret{void \code{mobi2epub::}\bfcode{set\_out}}{std::string\& \emph{s}}{}
Sets {\hyperref[epub:vanilla_out__mutable-b]{\code{vanilla\_out}}} to \textbf{False}, then
changes {\hyperref[epub:path_tmp__boost::filesystem::path]{\code{path\_tmp}}} to

\end{fulllineitems}



\subsubsection{public}
\label{epub:public}\index{mobi2epub::mobi2epub (C++ function)}

\begin{fulllineitems}
\phantomsection\label{epub:mobi2epub::mobi2epub__mobi::mobireaderCR.b.b}\pysiglinewithargsret{ \code{mobi2epub::}\bfcode{mobi2epub}}{const mobi::mobireader\& \emph{m}, bool \emph{safe}\emph{=false}, bool \emph{no\_cleanup}\emph{=false}}{}
\end{fulllineitems}

\index{mobi2epub::save\_to\_directory (C++ function)}

\begin{fulllineitems}
\phantomsection\label{epub:mobi2epub::save_to_directoryC}\pysiglinewithargsret{void \code{mobi2epub::}\bfcode{save\_to\_directory}}{}{\code{~const}}
Calls {\hyperref[epub:mobi2epub::directory_structureC]{\code{mobi2epub::directory\_structure()}}} and {\hyperref[mobireader:mobireader::get_htmlC]{\code{mobireader::get\_html()}}}

splits the html on every new chapter mark:

\begin{Verbatim}[commandchars=\\\{\}]
\textless{}mbp:pagebreak/\textgreater{}
\end{Verbatim}

then iterates over it to
\begin{enumerate}
\item {} 
sanitize it as xhtml with {\hyperref[tidyhtml:epub::html::tidyhtml]{\code{epub::html::tidyhtml}}}

\item {} 
save it to {\hyperref[epub:path_tmp__boost::filesystem::path]{\code{path\_tmp}}} /OEBPS/text

\item {} 
build up {\hyperref[epub:itemid__ss]{\code{itemid}}} and {\hyperref[epub:itemref__ss]{\code{itemref}}} lists, which get passed to {\hyperref[epub:mobi2epub::gen_content_opf__std::stringstreamR.std::stringstreamRC]{\code{mobi2epub::gen\_content\_opf()}}} later on

\end{enumerate}

\end{fulllineitems}

\index{mobi2epub::save\_to\_directory (C++ function)}

\begin{fulllineitems}
\phantomsection\label{epub:mobi2epub::save_to_directory__ss}\pysiglinewithargsret{void \code{mobi2epub::}\bfcode{save\_to\_directory}}{std::string \emph{s}}{}
calls {\hyperref[epub:mobi2epub::set_out__ssR]{\code{mobi2epub::set\_out()}}} and
then proceeds to {\hyperref[epub:mobi2epub::save_to_directoryC]{\code{mobi2epub::save\_to\_directory()}}}

\end{fulllineitems}

\index{mobi2epub::directory\_to\_epub (C++ function)}

\begin{fulllineitems}
\phantomsection\label{epub:mobi2epub::directory_to_epubC}\pysiglinewithargsret{void \code{mobi2epub::}\bfcode{directory\_to\_epub}}{}{\code{~const}}
calls zip executable to compress everything in {\hyperref[epub:path_tmp__boost::filesystem::path]{\code{path\_tmp}}}
and save it to {\hyperref[epub:path_out__boost::filesystem::path]{\code{path\_out}}}

\begin{notice}{note}{Note:}
if it somehow compiles on windows and nothing fails up to this point, should throw {\hyperref[exceptions:epub::terrible_operating_system_exception]{\code{epub::terrible\_operating\_system\_exception}}}
\end{notice}

\end{fulllineitems}

\index{mobi2epub::directory\_to\_epub (C++ function)}

\begin{fulllineitems}
\phantomsection\label{epub:mobi2epub::directory_to_epub__ss}\pysiglinewithargsret{void \code{mobi2epub::}\bfcode{directory\_to\_epub}}{std::string \emph{s}}{}
Calls {\hyperref[epub:mobi2epub::set_out__ssR]{\code{mobi2epub::set\_out()}}} before calling actual {\hyperref[epub:mobi2epub::directory_to_epubC]{\code{mobi2epub::directory\_to\_epub()}}}

\end{fulllineitems}



\chapter{exceptions}
\label{exceptions:exceptions}\label{exceptions::doc}\index{mobi::not\_palmdoc\_compression\_exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{exceptions:mobi::not_palmdoc_compression_exception}\pysigline{\strong{class }\code{mobi::}\bfcode{not\_palmdoc\_compression\_exception}}
\end{fulllineitems}

\index{epub::file\_write\_exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{exceptions:epub::file_write_exception}\pysigline{\strong{class }\code{epub::}\bfcode{file\_write\_exception}}
\end{fulllineitems}

\index{epub::terrible\_operating\_system\_exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{exceptions:epub::terrible_operating_system_exception}\pysigline{\strong{class }\code{epub::}\bfcode{terrible\_operating\_system\_exception}}
\end{fulllineitems}

\index{epub::zip\_exit\_status\_exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{exceptions:epub::zip_exit_status_exception}\pysigline{\strong{class }\code{epub::}\bfcode{zip\_exit\_status\_exception}}
\end{fulllineitems}

\index{epub::path\_changed\_exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{exceptions:epub::path_changed_exception}\pysigline{\strong{class }\code{epub::}\bfcode{path\_changed\_exception}}
\end{fulllineitems}

\index{epub::user\_wants\_out\_exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{exceptions:epub::user_wants_out_exception}\pysigline{\strong{class }\code{epub::}\bfcode{user\_wants\_out\_exception}}
\end{fulllineitems}

\index{mobi::no\_such\_file\_exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{exceptions:mobi::no_such_file_exception}\pysigline{\strong{class }\code{mobi::}\bfcode{no\_such\_file\_exception}}
\end{fulllineitems}

\index{mobi::invalid\_file\_exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{exceptions:mobi::invalid_file_exception}\pysigline{\strong{class }\code{mobi::}\bfcode{invalid\_file\_exception}}
\end{fulllineitems}

\index{mobi::invalid\_compression\_type\_exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{exceptions:mobi::invalid_compression_type_exception}\pysigline{\strong{class }\code{mobi::}\bfcode{invalid\_compression\_type\_exception}}
\end{fulllineitems}

\index{mobi::section\_out\_of\_range\_exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{exceptions:mobi::section_out_of_range_exception}\pysigline{\strong{class }\code{mobi::}\bfcode{section\_out\_of\_range\_exception}}
\end{fulllineitems}

\index{mobi::unsupported\_compressiontype\_exception (C++ class)}

\begin{fulllineitems}
\phantomsection\label{exceptions:mobi::unsupported_compressiontype_exception}\pysigline{\strong{class }\code{mobi::}\bfcode{unsupported\_compressiontype\_exception}}
\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}
